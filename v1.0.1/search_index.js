var documenterSearchIndex = {"docs":
[{"location":"cn0_estimator.html#CN0-Estimator","page":"CN0 Estimator","title":"CN0 Estimator","text":"The CN0 (Carrier-to-Noise density ratio) estimator provides a measure of signal quality in dB-Hz.","category":"section"},{"location":"cn0_estimator.html#Default-Estimator","page":"CN0 Estimator","title":"Default Estimator","text":"The default CN0 estimator is the Moment Method implemented as MomentsCN0Estimator. It buffers prompt correlation values and estimates CN0 based on the signal and noise power moments.\n\nYou can adjust the buffer size for the MomentsCN0Estimator when creating a SatState:\n\nsat_state = SatState(\n    system, prn, code_phase, carrier_doppler,\n    num_prompts_for_cn0_estimation = 100  # Buffer size for MomentsCN0Estimator\n)","category":"section"},{"location":"cn0_estimator.html#Estimating-CN0","page":"CN0 Estimator","title":"Estimating CN0","text":"To get the CN0 estimate from a tracking state:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> sat_state1 = SatState(system, 1, 50.0, 1000.0Hz);\n\njulia> sat_state2 = SatState(system, 5, 120.0, -500.0Hz);\n\njulia> track_state = TrackState(system, [sat_state1, sat_state2]);\n\njulia> estimate_cn0(track_state, 1)  # Access by PRN\n0.0 dB-Hz\n\njulia> estimate_cn0(track_state, 5)  # Access by PRN\n0.0 dB-Hz\n\nNote: CN0 will be 0.0 dB-Hz until actual signal data has been processed through the tracking loop.","category":"section"},{"location":"cn0_estimator.html#Custom-CN0-Estimators","page":"CN0 Estimator","title":"Custom CN0 Estimators","text":"You can implement your own estimator by creating a subtype of AbstractCN0Estimator and implementing the following functions:\n\nupdate(cn0_estimator::MyCN0Estimator, prompt): Update the estimator with a new prompt value\nestimate_cn0(cn0_estimator::MyCN0Estimator, integration_time): Return the CN0 estimate\n\nPass your custom estimator when creating a SatState:\n\njulia> prn = 1;\n\njulia> code_phase = 50.0;\n\njulia> carrier_doppler = 1000.0Hz;\n\njulia> num_prompts = 100;  # Buffer size for MomentsCN0Estimator\n\njulia> sat_state = SatState(\n           system, prn, code_phase, carrier_doppler,\n           num_prompts_for_cn0_estimation = num_prompts\n       );\n\nPass your custom estimator to a SatState:\n\nsat_state = SatState(\n    sat_state;\n    cn0_estimator = MyCN0Estimator()\n)","category":"section"},{"location":"cn0_estimator.html#Tracking.MomentsCN0Estimator","page":"CN0 Estimator","title":"Tracking.MomentsCN0Estimator","text":"MomentsCN0Estimator to estimate the CN0\n\n\n\n\n\n","category":"type"},{"location":"cn0_estimator.html#Tracking.estimate_cn0","page":"CN0 Estimator","title":"Tracking.estimate_cn0","text":"estimate_cn0(estimator, integration_time)\n\n\nEstimates the CN0 based on the struct MomentsCN0Estimator.\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Correlator","page":"Correlator","title":"Correlator","text":"The correlator computes the correlation between the incoming signal and the locally generated replica code at multiple code phase offsets (early, prompt, late, etc.).","category":"section"},{"location":"correlator.html#Default-Correlators","page":"Correlator","title":"Default Correlators","text":"The default correlator depends on the GNSS system and is returned by get_default_correlator:\n\nEarlyPromptLateCorrelator for GPS L1, GPS L5 (BPSK modulation)\nVeryEarlyPromptLateCorrelator for Galileo E1B (BOC modulation)","category":"section"},{"location":"correlator.html#Correlator-Types","page":"Correlator","title":"Correlator Types","text":"","category":"section"},{"location":"correlator.html#Accessing-Correlator-Values","page":"Correlator","title":"Accessing Correlator Values","text":"","category":"section"},{"location":"correlator.html#Custom-Correlators","page":"Correlator","title":"Custom Correlators","text":"You can implement your own correlator by creating a subtype of AbstractCorrelator and implementing the required functions. See src/correlators/correlator.jl for the interface that needs to be implemented:\n\nget_accumulators(correlator): Return the accumulator values\nget_num_accumulators(correlator): Return the number of accumulators\nupdate_accumulator(correlator, accumulators): Create a new correlator with updated accumulators\nget_correlator_sample_shifts(correlator, sampling_frequency, code_frequency): Return the sample shifts for each accumulator","category":"section"},{"location":"correlator.html#Tracking.get_default_correlator","page":"Correlator","title":"Tracking.get_default_correlator","text":"get_default_correlator(gpsl1)\nget_default_correlator(gpsl1, num_ants)\n\n\nGet the default correlator for the given GNSS system. Returns an EarlyPromptLateCorrelator for GPS L1 or a VeryEarlyPromptLateCorrelator for systems like Galileo E1B that use BOC modulation.\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Tracking.EarlyPromptLateCorrelator","page":"Correlator","title":"Tracking.EarlyPromptLateCorrelator","text":"EarlyPromptLateCorrelator holding a user defined number of correlation values. The code is shifted in samples. Hence, the specified code shift is actually a preferred code shift, because depending on sampling frequency and  code frequency the specified code shift might not be the actual code shift. It is as close as possible, though. The algorithm makes sure that at least one sample is shifted.\n\n\n\n\n\n","category":"type"},{"location":"correlator.html#Tracking.VeryEarlyPromptLateCorrelator","page":"Correlator","title":"Tracking.VeryEarlyPromptLateCorrelator","text":"VeryEarlyPromptLateCorrelator holding a user defined number of correlation values. The code is shifted in samples. Hence, the specified code shift is actually a preferred code shift, because depending on sampling frequency and  code frequency the specified code shift might not be the actual code shift. It is as close as possible, though. The algorithm makes sure that at least one sample is shifted.\n\n\n\n\n\n","category":"type"},{"location":"correlator.html#Tracking.get_early","page":"Correlator","title":"Tracking.get_early","text":"get_early(correlator)\n\n\nGet early correlator\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Tracking.get_prompt","page":"Correlator","title":"Tracking.get_prompt","text":"get_prompt(correlator)\n\n\nGet prompt correlator\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Tracking.get_late","page":"Correlator","title":"Tracking.get_late","text":"get_late(correlator)\n\n\nGet late correlator\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Tracking.get_accumulators","page":"Correlator","title":"Tracking.get_accumulators","text":"get_accumulators(correlator)\n\n\nGet all correlator accumulators\n\n\n\n\n\n","category":"function"},{"location":"correlator.html#Tracking.get_num_accumulators","page":"Correlator","title":"Tracking.get_num_accumulators","text":"get_num_accumulators(correlator)\n\n\nGet number of accumulators\n\n\n\n\n\n","category":"function"},{"location":"loop_filter.html#Loop-Filter","page":"Loop Filter","title":"Loop Filter","text":"The loop filters are provided by TrackingLoopFilters.jl. This includes:\n\nfirst order loop filter FirstOrderLF\nsecond order bilinear loop filter SecondOrderBilinearLF\nsecond order boxcar loop filter SecondOrderBoxcarLF\nthird order bilinear loop filter ThirdOrderBilinearLF\nthird order boxcar loop filter ThirdOrderBoxcarLF\nthird order assisted bilinear loop filter ThirdOrderAssistedBilinearLF (combines PLL and FLL)","category":"section"},{"location":"loop_filter.html#Default-Configuration","page":"Loop Filter","title":"Default Configuration","text":"The default Doppler estimator is ConventionalAssistedPLLAndDLL which uses:\n\nThirdOrderAssistedBilinearLF for the carrier loop (FLL-assisted PLL for improved dynamics)\nSecondOrderBilinearLF for the code loop\n\nThe default bandwidths are:\n\nCarrier loop: 18 Hz\nCode loop: 1 Hz","category":"section"},{"location":"loop_filter.html#Doppler-Estimators","page":"Loop Filter","title":"Doppler Estimators","text":"","category":"section"},{"location":"loop_filter.html#Custom-Configuration","page":"Loop Filter","title":"Custom Configuration","text":"You can customize the loop filters and bandwidths when creating the Doppler estimator:\n\njulia> using Tracking, GNSSSignals, TrackingLoopFilters\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> sat_state = SatState(system, 1, 50.0, 1000.0Hz);\n\njulia> system_sats_state = SystemSatsState(system, sat_state);\n\njulia> # Use non-assisted PLL with custom loop filter types\n       doppler_estimator = ConventionalPLLAndDLL(\n           (system_sats_state,),\n           ThirdOrderBilinearLF,      # carrier loop filter type\n           SecondOrderBilinearLF;     # code loop filter type\n           carrier_loop_filter_bandwidth = 15.0Hz,\n           code_loop_filter_bandwidth = 0.5Hz\n       );\n\njulia> track_state = TrackState((system_sats_state,); doppler_estimator);","category":"section"},{"location":"loop_filter.html#Custom-Loop-Filters","page":"Loop Filter","title":"Custom Loop Filters","text":"You can implement a custom loop filter MyLoopFilter <: AbstractLoopFilter. In this case, a specialized filter_loop function is needed. For more information refer to TrackingLoopFilters.jl.","category":"section"},{"location":"loop_filter.html#Tracking.ConventionalPLLAndDLL","page":"Loop Filter","title":"Tracking.ConventionalPLLAndDLL","text":"Conventional Phase-Locked Loop (PLL) and Delay-Locked Loop (DLL) Doppler estimator. Uses configurable loop filters for carrier and code tracking with adjustable bandwidths.\n\n\n\n\n\n","category":"type"},{"location":"loop_filter.html#Tracking.ConventionalAssistedPLLAndDLL","page":"Loop Filter","title":"Tracking.ConventionalAssistedPLLAndDLL","text":"ConventionalAssistedPLLAndDLL(\n    multiple_system_sats_state;\n    ...\n)\nConventionalAssistedPLLAndDLL(\n    multiple_system_sats_state,\n    ;\n    carrier_loop_filter_bandwidth,\n    code_loop_filter_bandwidth\n)\n\n\nCreate a ConventionalPLLAndDLL with FLL-assisted carrier tracking. This is the default Doppler estimator used by TrackState. Uses a ThirdOrderAssistedBilinearLF for the carrier loop filter which combines PLL and FLL discriminators for improved tracking under high dynamics.\n\n\n\n\n\n","category":"function"},{"location":"track.html#Track","page":"Track","title":"Track","text":"The track function is the main entry point for processing GNSS signals. It takes an incoming signal and a TrackState, performs downconversion and correlation for all tracked satellites, estimates Doppler frequencies, and returns an updated TrackState.","category":"section"},{"location":"track.html#Function-Reference","page":"Track","title":"Function Reference","text":"","category":"section"},{"location":"track.html#Optional-Parameters","page":"Track","title":"Optional Parameters","text":"downconvert_and_correlator: The downconversion and correlation implementation to use. Defaults to CPUDownconvertAndCorrelator.\nintermediate_frequency: The intermediate frequency of the signal. Defaults to 0.0Hz.\npreferred_num_code_blocks_to_integrate: The preferred number of code blocks to integrate. Defaults to 1. Will only integrate more than one block once bit synchronization has been achieved.","category":"section"},{"location":"track.html#Downconversion-and-Correlation","page":"Track","title":"Downconversion and Correlation","text":"","category":"section"},{"location":"track.html#Correlator-Sample-Shifts","page":"Track","title":"Correlator Sample Shifts","text":"","category":"section"},{"location":"track.html#Tracking.track","page":"Track","title":"Tracking.track","text":"track(\n    signal,\n    track_state,\n    sampling_frequency;\n    downconvert_and_correlator,\n    intermediate_frequency,\n    preferred_num_code_blocks_to_integrate\n)\n\n\nMain tracking function that processes a signal and updates the tracking state. Performs downconversion, correlation, and Doppler estimation for all satellites in the track state. Returns an updated TrackState with new phase/Doppler estimates and decoded bits.\n\n\n\n\n\n","category":"function"},{"location":"track.html#Tracking.CPUDownconvertAndCorrelator","page":"Track","title":"Tracking.CPUDownconvertAndCorrelator","text":"CPU-based implementation of downconversion and correlation. Uses LoopVectorization for SIMD-optimized processing. The MESF type parameter specifies the maximum expected sampling frequency for buffer allocation.\n\n\n\n\n\n","category":"type"},{"location":"track.html#Tracking.AbstractDownconvertAndCorrelator","page":"Track","title":"Tracking.AbstractDownconvertAndCorrelator","text":"Abstract downconverter and correlator type. Structs for downconversion and correlation must have this abstract type as a parent.\n\n\n\n\n\n","category":"type"},{"location":"track.html#Tracking.get_correlator_sample_shifts","page":"Track","title":"Tracking.get_correlator_sample_shifts","text":"get_correlator_sample_shifts(\n    correlator,\n    sampling_frequency,\n    code_frequency\n)\n\n\nCalculate the replica phase offset required for the correlator with respect to the prompt correlator, expressed in samples. The shifts are ordered from latest to earliest replica.\n\n\n\n\n\nget_correlator_sample_shifts(\n    correlator,\n    sampling_frequency,\n    code_frequency\n)\n\n\nCalculate the replica phase offset required for the correlator with respect to the prompt correlator, expressed in samples. The shifts are ordered from latest to earliest replica.\n\n\n\n\n\n","category":"function"},{"location":"track.html#Tracking.get_early_late_sample_spacing","page":"Track","title":"Tracking.get_early_late_sample_spacing","text":"get_early_late_sample_spacing(\n    correlator,\n    sampling_frequency,\n    code_frequency\n)\n\n\nCalculate the total spacing between early and late correlator in samples.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Tracking.jl","page":"Tracking.jl","title":"Tracking.jl","text":"This package implements the tracking functionality of GNSS satellites that's part of the larger GNSS receiver. Tracking.jl primarily consists of two main blocks:\n\nSignal down-conversion and correlation\nCode and carrier estimation to generate replicas and close the loop\n\nTracking.jl provides defaults for both blocks, but it provides mechanisms to hook in your own implementation (by using multiple dispatch). For signal down-conversion and correlation Tracking.jl provides a highly optimized CPU implementation using SIMD vectorization via LoopVectorization.jl. With respect to the second block Tracking.jl provides conventional DLLs and PLLs with FLL-assisted carrier tracking as the default. Down-conversion and correlation is done in full code blocks meaning from code start to code end or multiples of that (e.g. in GPS L1 from 0 to N*1023). The factor N can be specified, but will be 1 as long as the bit start is unknown in order to find the bit start. Once that is done for every tracked satellite the result will be handed over to the code and carrier estimation block. Moreover, Tracking.jl allows tracking of signals from phased antenna arrays meaning that they are down-converted and correlated by the very same replica to conserve phase relationships.\n\nPages = [\n  \"track.md\",\n  \"tracking_state.md\",\n  \"loop_filter.md\",\n  \"correlator.md\",\n  \"cn0_estimator.md\"\n]\nDepth = 1","category":"section"},{"location":"index.html#Installation","page":"Tracking.jl","title":"Installation","text":"julia> ]\npkg> add Tracking","category":"section"},{"location":"index.html#Usage","page":"Tracking.jl","title":"Usage","text":"Tracking.jl can track one or multiple satellites simultaneously. The tracking state is held in a TrackState which contains SatState objects for each tracked satellite.","category":"section"},{"location":"index.html#Single-Satellite-Tracking","page":"Tracking.jl","title":"Single Satellite Tracking","text":"To track a single satellite, create a SatState with the GNSS system, PRN, code phase, and carrier Doppler (typically from acquisition):\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> prn = 1;\n\njulia> code_phase = 50.0;\n\njulia> carrier_doppler = 1000.0Hz;\n\njulia> sat_state = SatState(system, prn, code_phase, carrier_doppler);\n\njulia> track_state = TrackState(system, sat_state);\n\njulia> get_prn(track_state)\n1\n\njulia> get_code_phase(track_state)\n50.0\n\njulia> get_carrier_doppler(track_state)\n1000.0 Hz\n\nTo process a signal, call the track function. The signal should be a vector of complex samples:\n\njulia> using GNSSSignals: gen_code, get_code_frequency, get_code_center_frequency_ratio\n\njulia> sampling_frequency = 4e6Hz;\n\njulia> num_samples = 4000;\n\njulia> code_frequency = carrier_doppler * get_code_center_frequency_ratio(system) + get_code_frequency(system);\n\njulia> signal = cis.(2Ï€ .* carrier_doppler .* (0:num_samples-1) ./ sampling_frequency) .*\n           gen_code(num_samples, system, prn, sampling_frequency, code_frequency, code_phase);\n\njulia> track_state = track(signal, track_state, sampling_frequency);\n\nAfter tracking, you can retrieve the updated tracking parameters and results:\n\njulia> get_carrier_doppler(track_state)\n999.9999883655299 Hz\n\njulia> get_code_phase(track_state)\n50.00064935064897\n\njulia> get_prompt(get_last_fully_integrated_correlator(track_state))\n3805.0 - 0.000841952976770699im\n\nNote: estimate_cn0(track_state) returns the CN0 estimate in dB-Hz. With a noise-free test signal, this will be Inf dB-Hz. With real signals containing noise, you'll get finite values typically in the range of 30-50 dB-Hz.","category":"section"},{"location":"index.html#Multiple-Satellite-Tracking","page":"Tracking.jl","title":"Multiple Satellite Tracking","text":"To track multiple satellites of the same system:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> sat_state1 = SatState(system, 1, 50.0, 1000.0Hz);\n\njulia> sat_state2 = SatState(system, 5, 120.0, -500.0Hz);\n\njulia> sat_state3 = SatState(system, 17, 890.0, 2000.0Hz);\n\njulia> track_state = TrackState(system, [sat_state1, sat_state2, sat_state3]);\n\njulia> get_carrier_doppler(track_state, 5)\n-500.0 Hz\n\njulia> get_code_phase(track_state, 17)\n890.0","category":"section"},{"location":"index.html#Multi-System-Tracking","page":"Tracking.jl","title":"Multi-System Tracking","text":"Tracking.jl supports tracking satellites from different GNSS systems simultaneously:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> gps_sat = SatState(GPSL1(), 1, 50.0, 1000.0Hz);\n\njulia> galileo_sat = SatState(GalileoE1B(), 11, 200.0, -300.0Hz);\n\njulia> gps_system_state = SystemSatsState(GPSL1(), gps_sat);\n\njulia> galileo_system_state = SystemSatsState(GalileoE1B(), galileo_sat);\n\njulia> track_state = TrackState((gps_system_state, galileo_system_state));\n\njulia> get_carrier_doppler(track_state, 1, 1)  # system 1, PRN 1\n1000.0 Hz\n\njulia> get_carrier_doppler(track_state, 2, 11)  # system 2, PRN 11\n-300.0 Hz\n\nYou can also use a named tuple for easier access:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> gps_sat = SatState(GPSL1(), 1, 50.0, 1000.0Hz);\n\njulia> galileo_sat = SatState(GalileoE1B(), 11, 200.0, -300.0Hz);\n\njulia> gps_system_state = SystemSatsState(GPSL1(), gps_sat);\n\njulia> galileo_system_state = SystemSatsState(GalileoE1B(), galileo_sat);\n\njulia> track_state = TrackState((gps = gps_system_state, galileo = galileo_system_state));\n\njulia> get_carrier_doppler(track_state, :gps, 1)\n1000.0 Hz\n\njulia> get_carrier_doppler(track_state, :galileo, 11)\n-300.0 Hz","category":"section"},{"location":"index.html#Adding-and-Removing-Satellites","page":"Tracking.jl","title":"Adding and Removing Satellites","text":"Satellites can be dynamically added or removed during tracking:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> sat_state = SatState(system, 1, 50.0, 1000.0Hz);\n\njulia> track_state = TrackState(system, sat_state);\n\njulia> new_sat = SatState(system, 23, 500.0, 1500.0Hz);\n\njulia> track_state = merge_sats(track_state, new_sat);\n\njulia> get_carrier_doppler(track_state, 23)\n1500.0 Hz\n\njulia> track_state = filter_out_sats(track_state, [1]);\n\njulia> haskey(get_sat_states(track_state), 23)\ntrue\n\njulia> haskey(get_sat_states(track_state), 1)\nfalse","category":"section"},{"location":"index.html#Track-Multiple-Signals-Coherently-(Phased-Arrays)","page":"Tracking.jl","title":"Track Multiple Signals Coherently (Phased Arrays)","text":"Tracking.jl provides a way to track multiple signals coherently, e.g. to track signals from a phased array. In that case the input signal should be a Matrix instead of a Vector, where the number of rows is equal to the number of samples and the number of columns is equal to the number of antenna elements. Furthermore, you need to specify the number of antenna elements to the satellite state:\n\njulia> using Tracking, GNSSSignals\n\njulia> using Tracking: Hz\n\njulia> system = GPSL1();\n\njulia> sat_state = SatState(system, 1, 50.0, 1000.0Hz, num_ants = NumAnts(4));\n\njulia> track_state = TrackState(system, sat_state);\n\njulia> get_num_ants(track_state)\n4\n\nBy default the track function will use the first antenna channel as the reference signal to drive the discriminators. However, an appropriate beamforming algorithm will probably suit better. For that, you can pass a custom post_corr_filter to the SatState.","category":"section"},{"location":"index.html#GPU-Support","page":"Tracking.jl","title":"GPU Support","text":"To use GPU acceleration features, you need to explicitly load CUDA:\n\nusing Tracking\nusing CUDA  # Activates GPU functionality\n\n# Access GPU types via the extension\next = Base.get_extension(Tracking, :TrackingCUDAExt)\ngpu_correlator = ext.GPUDownconvertAndCorrelator(...)\n\nNote: The GPU implementation is available for reference but is not yet as optimized as the CPU implementation which uses SIMD vectorization via LoopVectorization.jl.","category":"section"},{"location":"index.html#Q/A","page":"Tracking.jl","title":"Q/A","text":"Why are the correlator values zero?\n\nThe correlator output given by get_last_fully_integrated_correlator is the correlation result after the code phase has reached the full code length or multiples of the code length. If the current tracked signal does not include the end of the PRN sequence (or multiples of that), the correlator from the last complete integration will be returned. At the very start of tracking, before any complete integration has occurred, the correlator values will be zero.","category":"section"},{"location":"tracking_state.html#Tracking-State","page":"Tracking State","title":"Tracking State","text":"Tracking.jl uses a hierarchy of state types to manage tracking across multiple satellites and GNSS systems.","category":"section"},{"location":"tracking_state.html#TrackState","page":"Tracking State","title":"TrackState","text":"The main container for all tracking state. It holds satellite states for one or more GNSS systems and the Doppler estimator (PLL/DLL).","category":"section"},{"location":"tracking_state.html#SatState","page":"Tracking State","title":"SatState","text":"Per-satellite tracking state containing phase, Doppler, correlator, and bit buffer information.","category":"section"},{"location":"tracking_state.html#SatState-Accessor-Functions","page":"Tracking State","title":"SatState Accessor Functions","text":"","category":"section"},{"location":"tracking_state.html#SystemSatsState","page":"Tracking State","title":"SystemSatsState","text":"Container for multiple satellites of the same GNSS system.","category":"section"},{"location":"tracking_state.html#Multi-System-Support","page":"Tracking State","title":"Multi-System Support","text":"","category":"section"},{"location":"tracking_state.html#Modifying-Tracking-State","page":"Tracking State","title":"Modifying Tracking State","text":"","category":"section"},{"location":"tracking_state.html#Tracking.TrackState","page":"Tracking State","title":"Tracking.TrackState","text":"Main tracking state container holding satellite states for multiple GNSS systems and the Doppler estimator (e.g., PLL/DLL). This is the primary struct used for tracking operations.\n\n\n\n\n\n","category":"type"},{"location":"tracking_state.html#Tracking.SatState","page":"Tracking State","title":"Tracking.SatState","text":"Holds the state of a single satellite being tracked. Contains code and carrier phase/doppler information, correlator state, CN0 estimator, and bit buffer.\n\n\n\n\n\n","category":"type"},{"location":"tracking_state.html#Tracking.get_prn","page":"Tracking State","title":"Tracking.get_prn","text":"get_prn(s)\n\n\nGet the PRN (Pseudo-Random Noise) number of the satellite.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_code_phase","page":"Tracking State","title":"Tracking.get_code_phase","text":"get_code_phase(s)\n\n\nGet the current code phase in chips.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_code_doppler","page":"Tracking State","title":"Tracking.get_code_doppler","text":"get_code_doppler(s)\n\n\nGet the current code Doppler frequency.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_carrier_phase","page":"Tracking State","title":"Tracking.get_carrier_phase","text":"get_carrier_phase(s)\n\n\nGet the current carrier phase in radians.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_carrier_doppler","page":"Tracking State","title":"Tracking.get_carrier_doppler","text":"get_carrier_doppler(s)\n\n\nGet the current carrier Doppler frequency.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_integrated_samples","page":"Tracking State","title":"Tracking.get_integrated_samples","text":"get_integrated_samples(s)\n\n\nGet the number of samples that have been integrated so far.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_signal_start_sample","page":"Tracking State","title":"Tracking.get_signal_start_sample","text":"get_signal_start_sample(s)\n\n\nGet the starting sample index in the signal for the next integration.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_correlator","page":"Tracking State","title":"Tracking.get_correlator","text":"get_correlator(s)\n\n\nGet the current correlator state.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_last_fully_integrated_correlator","page":"Tracking State","title":"Tracking.get_last_fully_integrated_correlator","text":"get_last_fully_integrated_correlator(s)\n\n\nGet the correlator from the last fully completed integration period.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_last_fully_integrated_filtered_prompt","page":"Tracking State","title":"Tracking.get_last_fully_integrated_filtered_prompt","text":"get_last_fully_integrated_filtered_prompt(s)\n\n\nGet the filtered prompt value from the last fully completed integration period.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_bit_buffer","page":"Tracking State","title":"Tracking.get_bit_buffer","text":"get_bit_buffer(s)\n\n\nGet the bit buffer containing decoded navigation bits.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_bits","page":"Tracking State","title":"Tracking.get_bits","text":"get_bits(s)\n\n\nGet the decoded navigation bits as an integer.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_num_bits","page":"Tracking State","title":"Tracking.get_num_bits","text":"get_num_bits(s)\n\n\nGet the number of decoded navigation bits.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.has_bit_or_secondary_code_been_found","page":"Tracking State","title":"Tracking.has_bit_or_secondary_code_been_found","text":"has_bit_or_secondary_code_been_found(s)\n\n\nCheck if the bit or secondary code synchronization has been achieved.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.SystemSatsState","page":"Tracking State","title":"Tracking.SystemSatsState","text":"Holds the state of multiple satellites for a single GNSS system. Contains the system definition and a dictionary of satellite states indexed by identifier.\n\n\n\n\n\n","category":"type"},{"location":"tracking_state.html#Tracking.MultipleSystemSatsState","page":"Tracking State","title":"Tracking.MultipleSystemSatsState","text":"Type alias for a tuple or named tuple of SystemSatsState objects, representing tracking state across multiple GNSS systems.\n\n\n\n\n\n","category":"type"},{"location":"tracking_state.html#Tracking.get_system_sats_state","page":"Tracking State","title":"Tracking.get_system_sats_state","text":"get_system_sats_state(track_state, system_idx)\n\n\nGet the SystemSatsState for a specific GNSS system from a TrackState or MultipleSystemSatsState by index or symbol.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_sat_states","page":"Tracking State","title":"Tracking.get_sat_states","text":"get_sat_states(multiple_system_sats_state, system_idx)\n\n\nGet the dictionary of satellite states for a specific GNSS system.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_sat_state","page":"Tracking State","title":"Tracking.get_sat_state","text":"get_sat_state(sss, identifier)\n\n\nGet the satellite state for a specific satellite identifier.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.get_system","page":"Tracking State","title":"Tracking.get_system","text":"get_system(sss)\n\n\nGet the GNSS system definition from a SystemSatsState.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.merge_sats","page":"Tracking State","title":"Tracking.merge_sats","text":"merge_sats(\n    multiple_system_sats_state,\n    system_idx,\n    new_sat_states\n)\n\n\nMerge new satellite states into the existing tracking state. Adds or updates satellites in the specified system.\n\n\n\n\n\n","category":"function"},{"location":"tracking_state.html#Tracking.filter_out_sats","page":"Tracking State","title":"Tracking.filter_out_sats","text":"filter_out_sats(\n    multiple_system_sats_state,\n    system_idx,\n    identifiers\n)\n\n\nRemove satellites with the specified identifiers from the tracking state.\n\n\n\n\n\n","category":"function"}]
}
